---
layout: post
title:  "Generating an icosphere with code"
date:   2024/06/11 17:29:00 +0200
author: Matheus Amazonas
categories: jekyll update
---

# Introduction
In this article, we will walk through the process of generating an icosphere (a sphere based on a regular icosahedron) with code. The process consists of 2 steps: generating a regular icosahedron and mesh fragmentation.

Even though the article uses C# as its guiding programming language, the code described here should be easily translatable to other programming languages. 

If you're looking for a tool to procedurally generate spheres in Unity, check [Sphere Generator](https://github.com/matheusamazonas/sphere_generator). 

# The icosphere
Before jumping into details, it's important to understand what is an icosphere. It's uncertain (at least to me) who invented the term icosphere, but the most popular usage of the term is in the 3D modeling tool [Blender](https://docs.blender.org/manual/en/dev/modeling/meshes/primitives.html#icosphere), which defines the term as:

> An icosphere is a polyhedral* sphere made up of triangles. Icospheres are normally used to achieve a more isotropical layout of vertices than a UV sphere, in other words, they are uniform in every direction.

\*: *A polyhedral shape is a shape that represents a [polyhedron](https://en.wikipedia.org/wiki/Polyhedron): a 3-dimensional shape with flat, polygonal faces. Examples of polyhedrons: pyramid, cube.* 

The image below displays an example of an icosphere with 1920 vertices:
![A white sphere composed by a mesh of equilateral triangles with gray edges. Transparent background](icosphere.png)



## Nature 
Knowing what an icosphere looks like is one thing. Knowing how to generate one is something completely different. In order to learn how to generate icsphere meshes procedurally, we need to understand the concepts behind it. First of all, how can we conceptually define an icosphere?

> An icosphere is generated by fragmenting and normalizing a regular icosahedron (hence the *ico-* prefix). 

Let's break that sentence down. First, what on earth is an icosahedron, and what makes one regular?

An [icosahedron](https://en.wikipedia.org/wiki/Icosahedron) is a polyhedron with 20 faces. There is an infinite number of icosahedrons, and the most famous one is the [regular icosahedron](https://en.wikipedia.org/wiki/Regular_icosahedron), a convex polyhedron composed of 20 equilateral triangles. The regular icosahedron is one of the five [Platonic solids](https://en.wikipedia.org/wiki/Platonic_solid). This is how it looks like:

![](icosahedron_loop.gif)

The process described in this article transforms a regular icosahedron (the shape above) into spheres. It consists of three steps:
1. Creating an icosahedron.
2. Fragmentation.
3. Normalization.

Steps 2 and 3 "augment" the icosphere generated on step 1. That's what the "augmenting" in the icosphere definition referred to. The image below  

![](process_loop.gif)

Now that we know what a regular icosahedron looks like, let's dive into the other part of icosphere's definition: what does "augmenting" mean? The process of augmentation consists of increasing the number of faces of a polyhedron by fragmenting its faces. To fragment a face is to turn it into smaller polygons. In the case of an icosahedron, it means to break down each triangular face into 4 small triangles. The image below displays an example of a triangle that has been fragmented once:

![](fragment_1.svg)

Equilateral triangles are particularly easy to fragment. Like in every fragmentation process, the original vertices are maintained. Three new vertices are created by finding the mid-point of each edge. The coordinates (x, y, z) of a mid-point of an edge with vertices `v1` and `v2` can be calculated as:

```csharp
var x = (v1.x + v2.x) / 2;  
var y = (v1.y + v2.y) / 2;  
var z = (v1.z + v2.z) / 2;
```

The fragmentation process can be repeated indefinitely. Each iteration increases the number of triangles by a multiplying factor of 3, bringing the total number of triangles to 4 times the original one (1 + 3). The total number of iterations is often referred as fragmentation *depth* . The image below displays an example of a triangle that went through a fragmentation process with a depth of 2, resulting in 16 triangles (4Â²).

![](fragment_2.svg)

With this in mind, we can apply the fragmentation process o the regular icosahedron. The image below displays a regular icosahedron followed by 2 other meshes. The first one is the outcome of fragmenting the regular icosahedron with a depth of 1, and the last mesh with a depth value of 2.

> [!info] The images below display a fragmente

![](icosahedrons_2.png) 

## Characteristics
- Equilateral triangles.
- Consequently, all faces have the same area.
- Uniform in every direction. It doesn't have poles.
- Better fit for more natural shapes, particularly when UV mapping isn't required.

# Step 1: Generating a regular icosahedron
First, it's important to determine what it means to construct any 3D shape.


A [regular icosahedron](https://en.wikipedia.org/wiki/Regular_icosahedron) is a three-dimensional shape composed of 20 equilateral triangles. There are different paths one can take to construct a regular icosahedron. The path I took was to find the vertices by defining 3 mutually perpendicular 

![](regular_icosahedron.png)



It's about point distribution. We've got the distance.

## Finding plane coordinates
- Golden ratio
- Formulas here for the plane coordinates

## Constructing the sides


# Step 2: Fragmentation

![](icosahedrons.png) 

As we can see above, even though the number of triangles increases with every fragmentation iteration, the shape of the meshes remain the same. The faces gained new vertices, but their area remain untouched. the cause is clear: the new vertices are placed in the same plane as the triangle they originally belonged to. 

To fix issue, we can take advantage of one of the sphere's properties: all vertices on its surface are equally distant to the sphere's center. Knowing this, we can 

```csharp
for (var index = 0; index < vertices.Length; index++)  
{  
    var vertex = vertices[index];  
    vertices[index] = vertex.normalized * radius;  
}
```

![](icosahedrons_2.png) 

# Step 3: Normalization

# Conclusion

You might also like the previous [article](generating_spheres) 
